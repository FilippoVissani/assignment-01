%%%%
% Consiglio la visione dei seguenti tutorial:
% - https://www.youtube.com/watch?v=ihxSUsJB_14
% - https://www.youtube.com/watch?v=XTFWaV55uDo
%%%%
\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}

\newcommand{\thesislang}{italian} % decommentare in caso di tesi in italiano
%\newcommand{\thesislang}{english} % commentare in caso di tesi in italiano
\usepackage{thesis-style}

\begin{document}
	
\frontmatter

\input{front.tex}

%----------------------------------------------------------------------------------------
\tableofcontents   
%\listoffigures     % (optional) comment if empty
%\lstlistoflistings % (optional) comment if empty
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter{\introductionname}
\label{chap:introduction}
%----------------------------------------------------------------------------------------
\section{Descrizione}
Viene fornito il codice di un programma che simula il movimento di $N$ corpi su un piano bidimensionale,
soggetti a due tipi di forze:
\begin{itemize}
	\item una forza repulsiva, per cui ogni corpo $b_{i}$ esercita su ogni altro corpo $b_{j}$ una forza in modulo pari a:
	\begin{center}
		$ F_{ij} = \frac{k_{rep} \times m_{i}}{d^2_{ij}} $
	\end{center}
	Dove $m_{i}$ è la massa del corpo $b_{i}$, $k_{rep}$ è una costante data, $d_{ij}$ è la distanza fra i due corpi.
	La direzione della forza è data dal versore $(b_{i} - b_{j})$, ovvero respingente per il corpo $b_{j}$.
	\item Una forza di attrito, per cui su ogni corpo $b_{i}$ che si muove a una velocità $v_{i}$ è esercitata una forza:
	\begin{center}
		$ FR_{i} = - k_{fri} \times v_{i} $
	\end{center}
	Che si oppone al moto, quindi in direzione opposta alla sua velocità, dove $k_{fri}$ è una costante data.
\end{itemize}
Il programma è sequenziale, non strutturato. 
L'algoritmo \ref{lst:lst1} definisce il comportamento del simulatore in pseudo codice.
\newpage
\begin{lstlisting}[label=lst:lst1,caption=pseudocodice del programma sequenziale]
/* virtual time */
vt = 0;
/* time increment at each iteration */     
dt  = 0.01;

loop:
	for each body b[i]:
		compute total force exerted by other bodies b[j] and friction;
		compute the instant acceleration, given the total force and mass;
		update body velocity, given the acceleration and the virtual time elapsed dt;
	update bodies positions, given the velocity and virtual time elapsed dt;
	check boundary collisions;
	vt = vt + dt;   
	display current stage;

\end{lstlisting}

Alcuni aspetti rilevanti in merito al comportamento del programma e alla natura del problema:
\begin{itemize}
	\item Il calcolo delle forze al tempo $t$ avviene considerando coerentemente le posizioni dei corpi al tempo $t$. 
	\item L'aggiornamento delle posizioni può avvenire solo dopo che tutte le forze sono state calcolate (e le velocità aggiornate).
	\item Il controllo della collisione con i confini del mondo per un corpo $b_{i}$ può comportare il cambiamento della velocità e posizione del corpo.
	\item Nel programma, la visualizzazione dello stato corrente della simulazione o frame (via GUI) avviene in modo sincrono, per cui la successiva iterazione avviene solo dopo aver visualizzato lo stato della precedente.
\end{itemize}

\section{Obiettivi}
\subsection{Realizzazione di una Versione Concorrente della Simulazione}
Realizzare una versione concorrente della simulazione senza GUI, considerando un insieme iniziale $N$ di corpi
- e calcolando l'evoluzione temporale per un certo numero di passi $Nsteps$ -
con $Nsteps$ fissato come parametro. Posizione e velocità iniziali possono essere definite in modo casuale.
L'obiettivo è:
\begin{itemize}
	\item Massimizzare le performance, sfruttando tutte le capacità di calcolo del generico
	sistema di elaborazione su cui è mandato in esecuzione il programma.
	\item Organizzare il programma in modo modulare, estendibile.
\end{itemize}

Analizzare le performance del programma considerando valori di $N$ pari a 100, 1000, 5000, con $Nsteps$ pari a 1000, 10000, 50000,
calcolando lo speedup, e valutando il suo comportamento usando sia il numero ottimale teorico di thread,
sia considerando prove diverse con un numero variabile di threads per verificarne la scalabilità.
Verificare la correttezza del programma usando Java Path Finder, considerando la parte più significativa in merito, opportunamente semplificata.

\subsection{Inclusione di un'Interfaccia Grafica}
Estendere la simulazione includendo una GUI con pulsanti start/stop per lanciare/fermare la simulazione e visualizzare l'andamento,
includendo informazioni circa il tempo virtuale.
La GUI si presuppone visualizzi stati consistenti della simulazione (ma non necessariamente tutti gli stati).
%----------------------------------------------------------------------------------------
\chapter{Analisi del Problema}
\label{chap:Analisi del Problema}
%----------------------------------------------------------------------------------------
Portando il programma da sequenziale a parallelo devono essere considerati i seguenti aspetti:
\begin{itemize}
	\item Più flussi di esecuzione accedono in modo concorrente alla stessa lista di corpi.
	Quindi è necessario che i flussi siano sincronizzati (evitando deadlock, race contition, ecc...).
	\item La sincronizzazione deve avvenire in modo efficiente; bisogna sfruttare al massimo il tempo per
	la computazione evitando attese non necessarie.
	\item A ogni iterazione, dati due flussi di esecuzione $f_{i}$ e $f_{j}$, i quali eseguono computazioni su due corpi $c_{k}$ e $c_{w}$ rispettivamente (con $i \neq j$ e $k \neq w$),
	$f_{i}$ non deve aggiornare la posizione di $c_{k}$ prima che $f_{j}$ abbia terminato di calcolare la forza esercitata su $c_{w}$.
	\item La rappresentazione della simulazione deve rimanere
	consistente, i flussi devono essere sempre sincronizzati sulla
	stessa iterazione.
	\item È fondamentale che il numero di flussi di esecuzione venga scelto sulla base dei processori disponibili sulla macchina, ovvero
	rispettando la formula $N_{cpu} + 1$, per minimizzare il tempo di esecuzione.
	\item È buona pratica separare i componenti che riguardano la concorrenza dagli aspetti di logica e di grafica,
	così da rendere il sistema modulare ed estendibile.
	\item Gli eventi relativi alla pressione dei pulsanti
	devono essere gestiti atomicamente, dato che si occupano di
	avviare e fermare i flussi di esecuzione.
	\item Al termine della simulazione, sia nel caso in cui sia stato raggiunto
	il numero massimo di iterazioni, che nel caso in cui sia stato premuto il
	pulsante Stop, tutti i flussi di esecuzione devono terminare correttamente.
\end{itemize}

%----------------------------------------------------------------------------------------
\chapter{Descrizione dell'Architettura Proposta}
\label{chap:Descrizione dell'Architettura Proposta}
%----------------------------------------------------------------------------------------

In fase di progettazione, per separare al meglio gli aspetti di logica e grafica da quelli di concorrenza, si è scelto di
impiegare il pattern architetturale \textit{Model View Controller} (Figura \ref{fig:mvc}).
Gli aspetti di concorrenza vengono gestiti completamente nel \textit{Controller},
descritto più dettagliatamente in Figura \ref{fig:SimulatioManager}.
La classe \texttt{SimulationManager}, che implementa l'interfaccia \texttt{Runnable},
si occupa di generare i \texttt{Worker}, i quali a ogni iterazione
calcolano la nuova posizione dei corpi.
I \texttt{Worker} sono sincronizzati tra loro e con il \texttt{SimulationManager}
grazie a tre monitor di tipo barriera.
Nel Listato \ref{lst:lst3} viene riportata l'implementazione del metodo \texttt{await()} della classe \texttt{BarrierImpl}.
In questa implementazione l'ultimo worker che colpisce la barriera:
\begin{itemize}
	\item Risveglia tutti i worker che stanno attendendo.
	\item Imposta un flag che viene utilizzato per azzerare il campo
	che memorizza il numero di worker che hanno colpito la barriera.
	Questo perché le barriere vengono riutilizzate a ogni iterazione.
\end{itemize}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{figures/MVC-class-diagram.png}
	\caption{Model View Controller: diagramma delle classi.}
	\label{fig:mvc}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{figures/simulation-manager.png}
	\caption{Simulation manager: diagramma delle classi.}
	\label{fig:SimulatioManager}
\end{figure}

\begin{lstlisting}[float,
					language=Java,
					label=lst:lst3,caption=Implementazione della barrier]
public synchronized void hitAndWaitAll() throws InterruptedException {
	this.actualWorkers = this.actualWorkers + 1;
	if (this.actualWorkers == this.workersNumber) {
		this.exit = true;
		notifyAll();
	} else {
		while (this.actualWorkers < this.workersNumber && !this.exit) {
			wait();
		}
	}
	this.actualWorkers = this.actualWorkers - 1;
	if (this.actualWorkers == 0) this.exit = false;
}
\end{lstlisting}

%----------------------------------------------------------------------------------------
\chapter{Descrizione del Comportamento del Sistema} % possible chapter for Projects
\label{chap:Descrizione del Comportamento del Sistema}
%----------------------------------------------------------------------------------------

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{figures/petri-net.png}
	\caption{Rete di Petri.}
	\label{fig:petri-net}
\end{figure}

%----------------------------------------------------------------------------------------
\chapter{Verifica delle Prestazioni} % possible chapter for Projects
\label{chap:Verifica delle Prestazioni}
%----------------------------------------------------------------------------------------

I test sono stati effettuati su una macchina con le seguenti caratteristiche:
\begin{itemize}
	\item Sistema operativo: Fedora 35 (GNU/Linux)
	\item Versione kernel Linux: 5.16.18
	\item Ambiente desktop: Gnome 41.5
	\item Memoria: 16GB, 3200Mhz
	\item CPU: AMD Ryzen 7 5700U
\end{itemize}
Descrizione dettagliata del processore:
\begin{itemize}
	\item Core: 8
	\item Thread: 16
	\item Clock base: 1.8GHz
	\item Clock max: 4.3GHz
	\item Cache L2: 4MB
	\item Cache L3: 8MB
\end{itemize}

Osservando i dati riportati nella tabella \ref{tab:table1}
si possono trarre le seguenti conclusioni:
\begin{itemize}
	\item Per un numero di corpi sufficientemente piccolo (in questo caso 100),
	il programma sequenziale impiega meno tempo di quello concorrente.
	\item I valori proposti relativi al numero di corpi (100, 1000 e 5000) non sono sufficientemente elevati per
	dimostrare che $N_{cpu}+1$ è il numero ottimale di thread da usare. Infatti, considerando
	le simulazioni con numero di corpi e iterazioni elevati, la differenza dei tempi di esecuzione tra 9 e 17 thread è pressoché nulla.
\end{itemize}

In Figura \ref{fig:speedup} viene presentato un grafico che riporta l'andamento dello speedup in funzione del numero di corpi e di thread.
Nel migliore dei casi si ottiene uno speedup di poco superiore a 2.
Aumentando notevolmente il numero di corpi (50000), anche con un numero basso di iterazioni,
la differenza dei tempi di esecuzione diventa rilevante.
I risultati dei test riportati nella tabella \ref{tab:table2} dimostrano effettivamente che
il numero ottimale di thread da utilizzare è $N_{cpu} + 1$. In questo caso (forse a causa della semplicità del programma)
un numero di thread elevato (99) non produce un overhead significativo.

\begin{center}
	\begin{table}
		\begin{tabular}{ |c|c|c|c|c|c| } 
			\hline
			Numero test & Corpi & Iterazioni & Thread & Tempo esecuzione (ms) & Speedup \\
			\hline
			0 & 100 & 1000 & 1 & 165 & 1.0 \\ 
			\hline
		   1 & 100 & 1000 & 9 & 165 & 1.0 \\ 
			\hline
		   2 & 100 & 1000 & 17 & 393 & 0.42 \\ 
			\hline
		   3 & 100 & 1000 & 99 & 2414 & 0.07 \\ 
			\hline
		   4 & 100 & 10000 & 1 & 1140 & 1.0 \\ 
			\hline
		   5 & 100 & 10000 & 9 & 2666 & 0.43 \\ 
			\hline
		   6 & 100 & 10000 & 17 & 4737 & 0.24 \\ 
			\hline
		   7 & 100 & 10000 & 99 & 24731 & 0.05 \\ 
			\hline
		   8 & 100 & 50000 & 1 & 5612 & 1.0 \\ 
			\hline
		   9 & 100 & 50000 & 9 & 13653 & 0.41 \\ 
			\hline
		   10 & 100 & 50000 & 17 & 23923 & 0.23 \\ 
			\hline
		   11 & 100 & 50000 & 99 & 123088 & 0.05 \\ 
			\hline
		   12 & 1000 & 1000 & 1 & 8387 & 1.0 \\ 
			\hline
		   13 & 1000 & 1000 & 9 & 4131 & 2.03 \\ 
			\hline
		   14 & 1000 & 1000 & 17 & 4552 & 1.84 \\ 
			\hline
		   15 & 1000 & 1000 & 99 & 4727 & 1.77 \\ 
			\hline
		   16 & 1000 & 10000 & 1 & 82887 & 1.0 \\ 
			\hline
		   17 & 1000 & 10000 & 9 & 40312 & 2.06 \\ 
			\hline
		   18 & 1000 & 10000 & 17 & 44382 & 1.87 \\ 
			\hline
		   19 & 1000 & 10000 & 99 & 46137 & 1.8 \\ 
			\hline
		   20 & 1000 & 50000 & 1 & 413746 & 1.0 \\ 
			\hline
		   21 & 1000 & 50000 & 9 & 210688 & 1.96 \\ 
			\hline
		   22 & 1000 & 50000 & 17 & 229109 & 1.81 \\ 
			\hline
		   23 & 1000 & 50000 & 99 & 234906 & 1.76 \\ 
			\hline
		   24 & 5000 & 1000 & 1 & 183813 & 1.0 \\ 
			\hline
		   25 & 5000 & 1000 & 9 & 103834 & 1.77 \\ 
			\hline
		   26 & 5000 & 1000 & 17 & 102516 & 1.79 \\ 
			\hline
		   27 & 5000 & 1000 & 99 & 102355 & 1.8 \\ 
			\hline
		   28 & 5000 & 10000 & 1 & 1971397 & 1.0 \\ 
			\hline
		   29 & 5000 & 10000 & 9 & 1017581 & 1.94 \\ 
			\hline
		   30 & 5000 & 10000 & 17 & 1008593 & 1.95 \\ 
			\hline
		   31 & 5000 & 10000 & 99 & 1023304 & 1.93 \\ 
			\hline
		   32 & 5000 & 50000 & 1 & 10207974 & 1.0 \\ 
			\hline
		   33 & 5000 & 50000 & 9 & 5046146 & 2.02 \\ 
			\hline
		   34 & 5000 & 50000 & 17 & 5029016 & 2.03 \\ 
			\hline
		   35 & 5000 & 50000 & 99 & 5148153 & 1.98 \\ 
			\hline
		\end{tabular}
		\label{tab:table1}
		\caption{Risultati dei test}
	\end{table}
\end{center}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{figures/speedup-plot.png}
	\caption{Speedup in funzione del numero di thread e di corpi (con numero di iterazioni fissato a 50000).}
	\label{fig:speedup}
\end{figure}

\begin{center}
	\begin{table}
		\begin{tabular}{ |c|c|c|c|c|c| } 
			\hline
				Numero test & Corpi & Iterazioni & Thread & Tempo esecuzione (ms) & Speedup \\
			\hline
		   36 & 50000 & 100 & 1 & 7588885 & 1.0 \\ 
			\hline
		   37 & 50000 & 100 & 9 & 1595651 & 4.76 \\ 
			\hline
		   38 & 50000 & 100 & 17 & 1275306 & 5.95 \\ 
			\hline
		   39 & 50000 & 100 & 99 & 1276354 & 5.95 \\ 
			\hline
		\end{tabular}
		\label{tab:table2}
		\caption{Risultati dei test}
	\end{table}
\end{center}

%----------------------------------------------------------------------------------------
\chapter{Identificazione delle Proprietà di Correttezza} % possible chapter for Projects
\label{chap:Identificazione delle Proprietà di Correttezza}
%----------------------------------------------------------------------------------------

\end{document}